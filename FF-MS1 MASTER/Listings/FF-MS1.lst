C51 COMPILER V9.59.0.0   FF_MS1                                                            05/15/2021 14:51:49 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE FF_MS1
OBJECT MODULE PLACED IN .\Objects\FF-MS1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE FF-MS1.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\FF
                    --MS1.lst) TABS(2) OBJECT(.\Objects\FF-MS1.obj)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // TP5.c
   3          //-----------------------------------------------------------------------------
   4          // AUTH: 
   5          // DATE: 
   6          //
   7          // Target: C8051F02x
   8          // Tool chain: KEIL Microvision 4
   9          //
  10          //-----------------------------------------------------------------------------
  11          #include <C8051F020.h>
  12          #include "c8051F020_SFR16.h"
  13          #include "FF-MS1_Config.h"
  14          #include "FF-MS1_Divers.h"
  15          #include <stdlib.h>
  16          #include <string.h>
  17          
  18          #define Reset_Timer3Overflow TMR3CN &= 0x04
  19          #define Disable_Timer3 TMR3CN = 0x00
  20          
  21          sbit LED = P1^6;
  22          sbit Button = P3^7;
  23          sbit SLAVE_NSS = P0^7;
  24          char i = 0;
  25          char mCounter = 0;
  26          char SPIcounter = 0;
  27          char SPIlength = 0;
  28          char xdata message[10];
  29          char* ptr_message = &message;
  30          char xdata sendBuffer[14];
  31          char* ptr_sendBuffer = &sendBuffer;
  32          char xdata recieveBuffer[14];
  33          char* ptr_recieveBuffer;
  34          // Prototypes de Fonctions
  35          
  36          void Transfert(char c){
  37   1        for(i=0;i < 125;i++);
  38   1        SLAVE_NSS = 0;
  39   1        for(i=0;i < 10;i++);
  40   1        SPI0DAT = c;
  41   1      }
  42          
  43          void Codage (char SPIlength, char* ptr_sendBuffer, char* ptr_message){
  44   1        *ptr_sendBuffer++ = 'B';
  45   1        *ptr_sendBuffer++ = 'R';
  46   1        while (i < SPIlength){
  47   2          *ptr_sendBuffer++ = *ptr_message++;
  48   2          i++;
  49   2        }
  50   1        while (i < (10)){
  51   2          *ptr_sendBuffer++ = '&';
  52   2          i++;
  53   2        }
  54   1        //TODO : Ajout des caractères vides pour remplir
C51 COMPILER V9.59.0.0   FF_MS1                                                            05/15/2021 14:51:49 PAGE 2   

  55   1        *ptr_sendBuffer++ = 'U';
  56   1        *ptr_sendBuffer++ = 'H';
  57   1        i = 0;
  58   1      }
  59          
  60          //-----------------------------------------------------------------------------
  61          //-----------------------------------------------------------------------------
  62          // MAIN Routine
  63          //-----------------------------------------------------------------------------
  64          void main (void) {
  65   1        
  66   1          Init_Device();  // Appel des configurations globales
  67   1          
  68   1      // Début Insertion Code Configuration des périphériques ***********************
  69   1          EA = 1;
  70   1          LED = 0;
  71   1          SLAVE_NSS = 1;
  72   1        
  73   1      // Fin Code Initialisations ***************************************************
  74   1        
  75   1      // Début Insertion Code Phase Démarrage *************************************** 
  76   1            
  77   1            
  78   1      // Fin Code phase Démarrage ***************************************************
  79   1        
  80   1        
  81   1        while(1)
  82   1        {
  83   2          //Mettre le message à envoyer dans le buffer message, qui n'accepte que 10 char max.
  84   2          message[0] = 'E';
  85   2          message[1] = 'A';
  86   2          SPIlength = 2; //Spécifiez la longueur du message
  87   2          Codage(SPIlength,ptr_sendBuffer,ptr_message);
  88   2          /*
  89   2          
  90   2          if (recieve_flag) {
  91   2            recieve_flag = 0;
  92   2            if (recieveBuffer[1] == 'B' && recieveBuffer[2] == 'R'){
  93   2              while (j != lMessage){
  94   2                messageBuffer[j] = recieveBuffer[j+3];
  95   2                j++;
  96   2                }           
  97   2              if (messageBuffer[0] == 'E' && messageBuffer[1] == 'A'){
  98   2                LED = 1;
  99   2                }
 100   2              }
 101   2          }
 102   2          
 103   2          */
 104   2          
 105   2        }
 106   1      }
 107          
 108          //-----------------------------------------------------------------------------
 109          //-----------------------------------------------------------------------------
 110          // Fonctions de configuration des divers périphériques
 111          //-----------------------------------------------------------------------------
 112          // Insérez vos fonctions de configuration ici
 113          
 114          //-----------------------------------------------------------------------------
 115          //-----------------------------------------------------------------------------
 116          // Fonctions d'interruptions
C51 COMPILER V9.59.0.0   FF_MS1                                                            05/15/2021 14:51:49 PAGE 3   

 117          //-----------------------------------------------------------------------------
 118          // Insérez vos fonctions d'interruption ici
 119          
 120          void ISR_SPI0() interrupt 6{
 121   1        SPIF = 0;
 122   1        SLAVE_NSS = 1;
 123   1      }
 124          
 125          void ISR_TMR3() interrupt 14{
 126   1        Reset_Timer3Overflow;
 127   1        if (SPIcounter > 13){
 128   2          SPIcounter = 0;
 129   2        }
 130   1        else {
 131   2          Transfert(sendBuffer[SPIcounter]);
 132   2          SPIcounter++;
 133   2        }
 134   1        
 135   1        /*
 136   1        //Attente de 2 SCK, pour laisse le temps au Slave d'envoyer son message en retour
 137   1        
 138   1        *ptr_recieveBuffer++ = SPI0DAT;
 139   1        mCounter++;
 140   1        if (*ptr_recieveBuffer == 'H' && *ptr_recieveBuffer == 'U'){
 141   1          lMessage = mCounter-4;
 142   1          mCounter = 0;
 143   1          recieve_flag = 1;
 144   1        }
 145   1        if (i == 10){
 146   1          i = 0;
 147   1        }
 148   1        
 149   1        
 150   1        */
 151   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    365    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     38    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
